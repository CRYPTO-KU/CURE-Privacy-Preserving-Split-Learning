package ckkswrapper

import (
	"fmt"

	"github.com/tuneinsight/lattigo/v6/core/rlwe"
	"github.com/tuneinsight/lattigo/v6/schemes/ckks"
)

// HeContext holds the complete cryptographic context, including the secret key.
// It's meant to be owned by the CLIENT.
type HeContext struct {
	Params    ckks.Parameters
	Sk        *rlwe.SecretKey
	Encoder   *ckks.Encoder
	Encryptor *rlwe.Encryptor
	Decryptor *rlwe.Decryptor
}

// ServerKit contains all the public components the SERVER needs.
// It is generated by the client and does NOT include the secret key.
type ServerKit struct {
	Params    ckks.Parameters
	Encoder   *ckks.Encoder
	Evaluator *ckks.Evaluator
	Pk        *rlwe.PublicKey
	Evk       rlwe.EvaluationKeySet
}

// GetWorkerEvaluator returns a new Evaluator for use in a goroutine (not thread-safe to share Evaluator).
func (s *ServerKit) GetWorkerEvaluator() *ckks.Evaluator {
	// Each Evaluator must be constructed with the same params and evaluation keys.
	return ckks.NewEvaluator(s.Params, s.Evk)
}

// HasRotation returns true if the rotation key for r is present (stub for debug)
func (sk *ServerKit) HasRotation(r int) bool {
	return true // In real code, check Galois keys
}

// DefaultParams provides a recommended default parameter set for CKKS
var DefaultParams = struct {
	LogQ []int
	LogP []int
}{
	LogQ: []int{60, 40, 40, 40, 38},
	LogP: []int{60},
}

// NewHeContextWithParams creates a new HeContext from the given ckks.Parameters
func NewHeContextWithParams(params ckks.Parameters) *HeContext {
	kgen := rlwe.NewKeyGenerator(params)
	sk := kgen.GenSecretKeyNew()
	pk := kgen.GenPublicKeyNew(sk)
	encoder := ckks.NewEncoder(params)
	encryptor := rlwe.NewEncryptor(params, pk)
	decryptor := rlwe.NewDecryptor(params, sk)
	return &HeContext{
		Params:    params,
		Sk:        sk,
		Encoder:   encoder,
		Encryptor: encryptor,
		Decryptor: decryptor,
	}
}

// Update NewHeContext to use logN=15 by default
func NewHeContext() *HeContext {
	return NewHeContextWithLogN(15)
}

// NewHeContextWithLogN creates a new HeContext with a specified logN (ring size)
func NewHeContextWithLogN(logN int) *HeContext {
	paramsLit := ckks.ParametersLiteral{
		LogN:            logN,
		LogQ:            DefaultParams.LogQ,
		LogP:            DefaultParams.LogP,
		LogDefaultScale: 40,
		Xs:              rlwe.DefaultXs,
		Xe:              rlwe.DefaultXe,
	}
	ckksParams, err := ckks.NewParametersFromLiteral(paramsLit)
	if err != nil {
		panic(err)
	}
	return NewHeContextWithParams(ckksParams)
}

// GenServerKit produces everything the server needs.
// rotationKeys should be the list of rotations your model will require.
func (h *HeContext) GenServerKit(rotationKeys []int) *ServerKit {
	kgen := rlwe.NewKeyGenerator(h.Params)

	// Relinearization key
	rlk := kgen.GenRelinearizationKeyNew(h.Sk)

	// Galois (rotation) keys
	galEls := make([]uint64, len(rotationKeys))
	for i, rot := range rotationKeys {
		galEls[i] = h.Params.GaloisElementForRotation(rot)
	}
	galKeys := kgen.GenGaloisKeysNew(galEls, h.Sk)

	// Pack into a single evaluation-key structure
	evk := rlwe.NewMemEvaluationKeySet(rlk, galKeys...)
	evaluator := ckks.NewEvaluator(h.Params, evk)

	return &ServerKit{
		Params:    h.Params,
		Encoder:   ckks.NewEncoder(h.Params),
		Evaluator: evaluator,
		Pk:        kgen.GenPublicKeyNew(h.Sk),
		Evk:       evk,
	}
}

// Refresh ("Cheat-Strap") decrypts a ciphertext and re-encrypts it,
// resetting its level to maximum and cleaning its noise.
func (h *HeContext) Refresh(ct *rlwe.Ciphertext) *rlwe.Ciphertext {
	// 1. Decrypt the ciphertext to get the underlying plaintext.
	pt := h.Decryptor.DecryptNew(ct)

	// 2. Re-encrypt the plaintext. The new ciphertext will be at the max level.
	newCt, err := h.Encryptor.EncryptNew(pt)
	if err != nil {
		// This should ideally not happen in this flow.
		panic(fmt.Sprintf("failed to re-encrypt during refresh: %v", err))
	}

	return newCt
}
